\documentclass[a4paper,12pt]{article}
\usepackage[english]{varioref}
\usepackage{setspace}
\input{sections/packages}
\input{sections/FrontPage}
\onehalfspacing

\begin{document}
	\begin{titlepage}
		\maketitle
		\thispagestyle{empty}
	\end{titlepage}
	\cleardoublepage
	\newpage

\tableofcontents
\listoffigures
\thispagestyle{empty}

\newpage

\section{First problem}
\subsection{"division.c" file}
\justify{Source code:\\}

\begin{lstlisting}
#include <stdio.h>

int main(void){
    int D, d, r, q;
    __CPROVER_assume( (D < 0) && (D >= -300) && (d >= 0) );
    r = D;
    q = 0;
    while(r < 0){
        r = r + d;
        q--;
    }
    printf("quotient: %d, reminder: %d\n", q, r);
}
\end{lstlisting}

\subsubsection{Exercise 1:}
\textbf{Determine if there are any problems when trying to find the minimum number of unwinding needed by the loop for the values we assume in the macro. If there is any problem in the assumption that does not allow to have a bounded number of iterations, modify the assumption.\\}
\justify{Indeed, there's a problem in the assumption. We're assuming that the divisor 'd' can be equal to 0. This is a problem because we cannot divide by 0 because of the arithmetic rules, and in case we could, the value of 'r' would never change, in such a way that the loop would never end. Therefore, we've to modify the assumption removing the possibility of 'd' is 0 just modifying the last condition from (d $\geq$ 0) to (d $>$ 0).\\ 
\pagenumbering{arabic}
\newpage
The file with the modified assumption looks like:\\}

\begin{lstlisting}
#include <stdio.h>

int main(void){
    int D, d, r, q;
    __CPROVER_assume( (D < 0) && (D >= -300) && (d > 0) );
    r = D;
    q = 0;
    while(r < 0){
        r = r + d;
        q--;
    }
    printf("quotient: %d, reminder: %d\n", q, r);
}
\end{lstlisting}

\subsubsection{Exercise 2:}
\textbf{Insert assertions, with arithmetic expressions that involve \textit{D}, \textit{d}, \textit{q} and \textit{r}, to check that \textit{q} and \textit{r} are the quotient and the reminder, respectively, of the integer division of \textit{D} and \textit{d}. Check the assertions.\\}
\justify{To check if \textit{q} and \textit{r} are the quotient and the reminder, one \textit{assertion} has been added after the \textit{printf} command. In such a way that, after adding both assertions, the file code looks like:\\}

\begin{lstlisting}
#include <stdio.h>

int main(void){
    int D, d, r, q;
    __CPROVER_assume( (D < 0) && (D >= -300) && (d > 0) );
    r = D;
    q = 0;
    while(r < 0){
        r = r + d;
        q--;
    }
    printf("quotient: %d, reminder: %d\n", q, r);
    __CPROVER_assert((D == (q * d) + r), "Division check");
}
\end{lstlisting}

\justify{Instead of using one single macro, it could've been two.\\}

\begin{lstlisting}
__CPROVER_assert((q == D / d), "q is the quotient");
__CPROVER_assert((r == D % d), "r is the reminder");
\end{lstlisting}

\justify{But there's a problem. If a small negative number is divided by a big positive number, the real division is equal to -0.000... but the operator '/' rounds this division to -1. Therefore, the \textit{assertion} fails. The reasoning of the second assertion is the same as the first one. The division. The bad calculated division implies a wrong reminder.\\}

\begin{lstlisting}
cbmc --show-properties --pointer-check division.c
\end{lstlisting}

\justify{If the above is typed in the CMD, a list of the properties to check will be shown as it can be seen in the following picture.}

\begin{figure}[H]
    \centering
    \includegraphics[scale = 0.7]{images/props.jpg}
    \caption{List of properties}
    \label{fig:props}
\end{figure}

\justify{The last step is to check the different \textit{asserts}. This will be performed by typing the following command in the CMD:\\}

\begin{lstlisting}
cmbc --unwind k division.c
\end{lstlisting}

\justify{After executing the above command with \textit{k = 301}, to perform 300 iterations, the \textit{assertion} works ok. So, the verification is successful, as it can be seen in the following picture.}

\begin{figure}[H]
    \centering
    \includegraphics{images/ex1-succesful.jpg}
    \caption{Successful verification of the exercise 1 code.}
    \label{fig:success1}
\end{figure}

\subsubsection{Exercise 3:}
\textbf{Check for integer overflow bugs.\\}
\justify{To check for integer overflow bugs, the following command has to be executed in the CMD:\\}

\begin{lstlisting}
cbmc --trace --unwind k --signed-overflow-check division.c
\end{lstlisting}

\justify{After executing the above fixing the value of \textit{k} to 301, the algorithm cannot find any overflow bug, as can be seen in the following picture.}

\begin{figure}[H]
    \centering
    \includegraphics[scale = 0.7]{images/301arithmetic.jpg}
    \caption{Integer overflow bugs check performing 300 iterations.}
    \label{fig:300integerBug}
\end{figure}

\justify{To finish this exercise, it will proceed to check if fixing the value of \textit{k} to 1001, any bug can be found.}

\begin{figure}[H]
    \centering
    \includegraphics[scale = 0.7]{images/1001arithmetic.jpg}
    \caption{Integer overflow bugs check performing 1000 iterations.}
    \label{fig:1000integerBug}
\end{figure}

\justify{As it can be seen, neither with 1000 iterations, the algorithm can find any overflow bug.}

\section{Second problem}
\subsection{"simpleWhile.c" file}
\justify{Source code:}

\begin{lstlisting}
#define N 10
int main(){
    int numbers[N];
    int maxeven;
    int x = 0, i = 0;
    
    maxeven = 1;
    for(i = 0; i < N; i++){
        if(numbers[i] % 2 == 2){
            if(maxeven == 1 || maxeven < numbers[i]){
                maxeven = numbers[i];
            }
        }
    }
    if(maxeven != 1){
        // there are even numbers in the array,
        //so check that maxeven is the greatest one of them
    } else{
        // check that are NO even numbers in the array
    }
}
\end{lstlisting}

\section{Third problem}
\subsection{"sort.c" file}
\justify{Source code:}

\begin{lstlisting}
#include <stdint.h>
#define N 8

void sort(int8_t a[], int size){
    // write your favorite sorting algorithm
}

void checkSort(){
    int8_t array[N];
    int i;
    for (i = 0; i < N; ++i){
        // Assume numbers in array are integers in range [0, 16]
        __CPROVER__assume(array[i] >= 0 & array[i] <= 16);
    }
    
    sort(array, N);
    
    //write the assertions to check that the array is sorted
}
\end{lstlisting}

\end{document}
